#coding:utf-8
import socket
import re

#variables applicatives
shell = "2019shell1.picoctf.com"
port = 9525
regex = "picoCTF{.*?}"
s = socket.socket()
 
#fontion SockClose, logique de fermeture du socket
def SockClose():
    print("[*] Closing Shell")
    s.close()
    input()

#Fonction Exploit, payload/code à éxécuter, à modifier selon le problème du CTF
def Exploit():
    print("[*] Doing Black magic")
    peer = s.getpeername()
    print("[*] Connected to %s " % str(peer))
    r = s.recv(1024)
    print("[*] working Hard")
    while "}" not in str(r):
        r = s.recv(1024)
        result = re.findall(regex, str(r))
    if not str(result):
        print("[*] Bad Luck my friend")
    else:
        for f in result:
            print("[*] Lucky you, flag is : %s " % f)

#Fonction SockOpen, logique d'ouverture du socket
def SockOpen() :
    try :
        print("[*] Connecting to Shell %s on port %s" % (str(shell),str(port)))
        s.connect((shell,port))
        Exploit()
    except :
        print("[*] Impossible de se connecter au Shell %s " % str(shell))
        print("[*] Exploit failed")
    finally :
        SockClose()

#Program Main, appel la procédure SockOpen
SockOpen()
