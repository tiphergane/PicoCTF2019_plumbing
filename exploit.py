#!/usr/bin/env python3
# coding:utf-8
<<<<<<< HEAD
=======

>>>>>>> 37f7b71ee0d598fb194964cde8c3326e4d628cfd
import socket
import re

# variables applicatives
<<<<<<< HEAD
shell = "2019shell1.picoctf.com"
port = 9525
=======
shell = "jupiter.challenges.picoctf.org"
port = 7480
>>>>>>> 37f7b71ee0d598fb194964cde8c3326e4d628cfd
regex = "picoCTF{.*?}"
s = socket.socket()

# fontion SockClose, logique de fermeture du socket


def SockClose():
    print("[*] Closing Shell")
    s.close()


<<<<<<< HEAD
# Fonction Exploit, payload/code à éxécuter, à modifier selon le problème du CTF
=======
# Fonction Exploit, payload/code à éxécuter, à modifier selon le CTF


>>>>>>> 37f7b71ee0d598fb194964cde8c3326e4d628cfd
def Exploit():
    print("[*] Doing Black magic")
    r = s.recv(1024)
    print("[*] working Hard")
    while "}" not in str(r):
        r = s.recv(1024)
        result = re.findall(regex, str(r))
    if not str(result):
        print("[*] Bad Luck my friend")
    else:
        for f in result:
            print("[*] Lucky you, flag is : %s " % f)


# Fonction SockOpen, logique d'ouverture du socket
<<<<<<< HEAD
def SockOpen():
    try:
        print("[*] Connecting to Shell %s on port %s" %
              (str(shell), str(port)))
=======


def SockOpen():
    try:
        print("[*] Connecting to Shell %s : %s" % (str(shell), str(port)))
>>>>>>> 37f7b71ee0d598fb194964cde8c3326e4d628cfd
        s.connect((shell, port))
        Exploit()
    except:
        print("[*] Impossible de se connecter au Shell %s " % str(shell))
        print("[*] Exploit failed")
    finally:
        SockClose()


# Program Main, appel la procédure SockOpen
<<<<<<< HEAD
=======


>>>>>>> 37f7b71ee0d598fb194964cde8c3326e4d628cfd
SockOpen()
