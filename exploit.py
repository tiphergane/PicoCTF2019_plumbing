#coding:utf-8
import socket
import re

#variables applicatives
shell = "2019shell1.picoctf.com"
port = 9525
regex = "picoCTF{.*?}"
s = socket.socket()
 
#fontion SockClose, logique de fermeture du socket
def SockClose():
    print("[*] Closing Shell")
    s.close()
    input()

#Fonction Exploit, payload/code à éxécuter, à modifier selon le problème du CTF
def Exploit():
    s.connect((shell,port))
    print("[*] Doing Black magic")
    peer = s.getpeername()
    print("[*] Connected to %s " % str(peer))
    r = s.recv(1024)
    print("[*] working Hard")
    while "}" not in str(r):
        r = s.recv(1024)
        result = re.findall(regex, str(r))
        flag = result
        result = str(result)
    if not str(result):
        print("[*] Bad Luck my friend")
    else:
        for i in flag:
            print("[*] Lucky you, flag is : %s " % i)

#Fonction SockOpen, logique d'ouverture du socket
def SockOpen() :
    try : 
        print("[*] Connecting to Shell %s on port %s" % (str(shell),str(port)))
        Exploit()
    except :
        print("[*] Impossible de se connecter au Shell %s " % str(shell))    
    finally :
        SockClose()

#Program Main, appel la procédure SockOpen
SockOpen()
